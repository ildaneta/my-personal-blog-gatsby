{"version":3,"sources":["../../../src/schema/infer/inference-metadata.js"],"names":["isEqual","require","is32BitInteger","looksLikeADate","getType","value","key","includes","Date","String","Array","isArray","length","Object","keys","updateValueDescriptorObject","typeInfo","nodeId","operation","metadata","path","push","dprops","forEach","v","descriptor","undefined","updateValueDescriptor","pop","updateValueDescriptorArray","item","updateValueDescriptorRelNodes","listOfNodeIds","delta","nodes","dirty","updateValueDescriptorString","empty","example","typeName","total","first","mergeObjectKeys","dpropsKeysA","dpropsKeysB","otherProps","Set","concat","descriptorsAreEqual","otherDescriptor","types","possibleTypes","otherTypes","childDescriptorsAreEqual","type","array","dpropsKeys","object","every","prop","nodeFields","node","ignoredFields","filter","has","updateTypeMetadata","initialMetadata","disabled","ignored","fieldMap","field","id","ignore","set","disable","addNode","deleteNode","addNodes","reduce","isEmpty","hasNodes","typeMetadata","haveEqualFields","otherFieldMap","fields","state","module","exports"],"mappings":"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","sourcesContent":["/*\n## Incrementally track the structure of nodes with metadata\n\nThis metadata can be later utilized for schema inference\n(via building `exampleValue` or directly)\n\n### Usage example:\n\n```javascript\n  const node1 = { id: '1', foo: 25, bar: 'str' }\n  const node2 = { id: '1', foo: 'conflict' }\n\n  let meta = { ignoredFields: new Set(['id']) }\n  meta = addNode(meta, node1)\n  meta = addNode(meta, node2)\n  console.log(meta.fieldMap)\n  // outputs: {\n  //   foo: {\n  //     int: { total: 1, example: 25 },\n  //     string: { total: 1, example: 'conflict' },\n  //   },\n  //   bar: {\n  //     string: { total: 1, example: 'str' },\n  //   },\n  // }\n\n  const example1 = getExampleObject({ meta, typeName, typeConflictReporter })\n  console.log(example1)\n  // outputs { bar: 'str' }\n  // and reports conflicts discovered\n\n  meta = deleteNode(meta, node2)\n  console.log(meta.fieldMap)\n  // outputs: {\n  //   foo: {\n  //     int: { total: 1, example: 25 },\n  //     string: { total: 0, example: 'conflict' },\n  //   },\n  //   bar: { string: { total: 1, example: 'str' } },\n  // }\n\n  const example2 = getExampleObject({ meta, typeName, typeConflictReporter })\n  // outputs: { foo: 25, bar: 'str' }\n```\n\n`addNode`, `deleteNode`, `getExampleObject` are O(N) where N is the number\nof fields in the node object (including nested fields)\n\n### Metadata structure\n\n```javascript\ntype TypeMetadata = {\n  total?: number,\n  ignored?: boolean,\n  ignoredFields?: Set<string>,\n  fieldMap?: { [string]: ValueDescriptor },\n  typeName?: string,\n  dirty?: boolean, // tracks structural changes only\n  disabled?: boolean,\n}\n\ntype Count = number\ntype NodeId = string\n\ntype ValueDescriptor = {\n  int?: TypeInfoNumber,\n  float?: TypeInfoNumber,\n  date?: TypeInfoDate,\n  string?: TypeInfoString,\n  boolean?: TypeInfoBoolean,\n  array?: TypeInfoArray,\n  relatedNode?: TypeInfoRelatedNode,\n  relatedNodeList?: TypeInfoRelatedNode,\n  object?: TypeInfoObject,\n}\n\nabstract type TypeInfo = {\n  first?: NodeId | void, // Set to undefined if \"del\"\n  total: Count,\n}\n\ntype TypeInfoString = TypeInfo & {\n  empty: Count,\n  example: string,\n}\n\ntype TypeInfoDate = TypeInfo & {\n  example: string,\n}\n\ntype TypeInfoNumber = {\n  example: number,\n}\n\ntype TypeInfoBoolean = {\n  example: boolean,\n}\n\n// \"dprops\" is \"descriptor props\", which makes it easier to search for than \"props\"\ntype TypeInfoObject = TypeInfo & {\n  dprops?: {[name: \"number\" | \"string\" | \"boolean\" | \"null\" | \"date\" | \"string\" | \"array\" | \"object\"]: Descriptor},\n}\n\ntype TypeInfoArray = TypeInfo & {\n  item: ValueDescriptor,\n}\n\ntype TypeInfoRelatedNode = TypeInfo & {\n  nodes: { [NodeId]: Count }\n}\n\n```\n\n### Caveats\n\n* Conflict tracking for arrays is tricky, i.e.: { a: [5, \"foo\"] } and { a: [5] }, { a: [\"foo\"] }\n  are represented identically in metadata. To workaround it we additionally track first NodeId:\n  { a: { array: { item: { int: { total: 1, first: `1` }, string: { total: 1, first: `1` } }}\n  { a: { array: { item: { int: { total: 1, first: `1` }, string: { total: 1, first: `2` } }}\n  This way we can produce more useful conflict reports\n  (still rare edge cases possible when reporting may be confusing, i.e. when node is deleted)\n*/\n\nconst { isEqual } = require(`lodash`)\nconst is32BitInteger = require(`./is-32-bit-integer`)\nconst { looksLikeADate } = require(`../types/date`)\n\nconst getType = (value, key) => {\n  // Staying as close as possible to GraphQL types\n  switch (typeof value) {\n    case `number`:\n      return is32BitInteger(value) ? `int` : `float`\n    case `string`:\n      if (key.includes(`___NODE`)) {\n        return `relatedNode`\n      }\n      return looksLikeADate(value) ? `date` : `string`\n    case `boolean`:\n      return `boolean`\n    case `object`:\n      if (value === null) return `null`\n      if (value instanceof Date) return `date`\n      if (value instanceof String) return `string`\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return `null`\n        }\n        return key.includes(`___NODE`) ? `relatedNodeList` : `array`\n      }\n      if (!Object.keys(value).length) return `null`\n      return `object`\n    default:\n      // bigint, symbol, function, unknown (host objects in IE were typeof \"unknown\", for example)\n      return `null`\n  }\n}\n\nconst updateValueDescriptorObject = (\n  value,\n  typeInfo,\n  nodeId,\n  operation,\n  metadata,\n  path\n) => {\n  path.push(value)\n\n  const { dprops = {} } = typeInfo\n  typeInfo.dprops = dprops\n\n  Object.keys(value).forEach(key => {\n    const v = value[key]\n\n    let descriptor = dprops[key]\n    if (descriptor === undefined) {\n      descriptor = {}\n      dprops[key] = descriptor\n    }\n\n    updateValueDescriptor(nodeId, key, v, operation, descriptor, metadata, path)\n  })\n\n  path.pop()\n}\n\nconst updateValueDescriptorArray = (\n  value,\n  key,\n  typeInfo,\n  nodeId,\n  operation,\n  metadata,\n  path\n) => {\n  value.forEach(item => {\n    let descriptor = typeInfo.item\n    if (descriptor === undefined) {\n      descriptor = {}\n      typeInfo.item = descriptor\n    }\n\n    updateValueDescriptor(\n      nodeId,\n      key,\n      item,\n      operation,\n      descriptor,\n      metadata,\n      path\n    )\n  })\n}\n\nconst updateValueDescriptorRelNodes = (\n  listOfNodeIds,\n  delta,\n  operation,\n  typeInfo,\n  metadata\n) => {\n  const { nodes = {} } = typeInfo\n  typeInfo.nodes = nodes\n\n  listOfNodeIds.forEach(nodeId => {\n    nodes[nodeId] = (nodes[nodeId] || 0) + delta\n\n    // Treat any new related node addition or removal as a structural change\n    // FIXME: this will produce false positives as this node can be\n    //  of the same type as another node already in the map (but we don't know it here)\n    if (nodes[nodeId] === 0 || (operation === `add` && nodes[nodeId] === 1)) {\n      metadata.dirty = true\n    }\n  })\n}\n\nconst updateValueDescriptorString = (value, delta, typeInfo) => {\n  if (value === ``) {\n    const { empty = 0 } = typeInfo\n    typeInfo.empty = empty + delta\n  }\n  typeInfo.example =\n    typeof typeInfo.example !== `undefined` ? typeInfo.example : value\n}\n\nconst updateValueDescriptor = (\n  nodeId,\n  key,\n  value,\n  operation = `add` /* add | del */,\n  descriptor,\n  metadata,\n  path\n) => {\n  // The object may be traversed multiple times from root.\n  // Each time it does it should not revisit the same node twice\n  if (path.includes(value)) {\n    return\n  }\n\n  const typeName = getType(value, key)\n\n  if (typeName === `null`) {\n    return\n  }\n\n  const delta = operation === `del` ? -1 : 1\n  let typeInfo = descriptor[typeName]\n  if (typeInfo === undefined) {\n    typeInfo = descriptor[typeName] = { total: 0 }\n  }\n  typeInfo.total += delta\n\n  // Keeping track of structural changes\n  // (when value of a new type is added or an existing type has no more values assigned)\n  if (typeInfo.total === 0 || (operation === `add` && typeInfo.total === 1)) {\n    metadata.dirty = true\n  }\n\n  // Keeping track of the first node for this type. Only used for better conflict reporting.\n  // (see Caveats section in the header comments)\n  if (operation === `add`) {\n    if (!typeInfo.first) {\n      typeInfo.first = nodeId\n    }\n  } else if (operation === `del`) {\n    if (typeInfo.first === nodeId || typeInfo.total === 0) {\n      typeInfo.first = undefined\n    }\n  }\n\n  switch (typeName) {\n    case `object`:\n      updateValueDescriptorObject(\n        value,\n        typeInfo,\n        nodeId,\n        operation,\n        metadata,\n        path\n      )\n      return\n    case `array`:\n      updateValueDescriptorArray(\n        value,\n        key,\n        typeInfo,\n        nodeId,\n        operation,\n        metadata,\n        path\n      )\n      return\n    case `relatedNode`:\n      updateValueDescriptorRelNodes(\n        [value],\n        delta,\n        operation,\n        typeInfo,\n        metadata\n      )\n      return\n    case `relatedNodeList`:\n      updateValueDescriptorRelNodes(value, delta, operation, typeInfo, metadata)\n      return\n    case `string`:\n      updateValueDescriptorString(value, delta, typeInfo)\n      return\n  }\n\n  // int, float, boolean, null\n\n  typeInfo.example =\n    typeof typeInfo.example !== `undefined` ? typeInfo.example : value\n}\n\nconst mergeObjectKeys = (dpropsKeysA, dpropsKeysB) => {\n  const dprops = Object.keys(dpropsKeysA)\n  const otherProps = Object.keys(dpropsKeysB)\n  return [...new Set(dprops.concat(otherProps))]\n}\n\nconst descriptorsAreEqual = (descriptor, otherDescriptor) => {\n  const types = possibleTypes(descriptor)\n  const otherTypes = possibleTypes(otherDescriptor)\n\n  const childDescriptorsAreEqual = type => {\n    switch (type) {\n      case `array`:\n        return descriptorsAreEqual(\n          descriptor.array.item,\n          otherDescriptor.array.item\n        )\n      case `object`: {\n        const dpropsKeys = mergeObjectKeys(\n          descriptor.object.dprops,\n          otherDescriptor.object.dprops\n        )\n        return dpropsKeys.every(prop =>\n          descriptorsAreEqual(\n            descriptor.object.dprops[prop],\n            otherDescriptor.object.dprops[prop]\n          )\n        )\n      }\n      case `relatedNode`:\n      case `relatedNodeList`: {\n        return isEqual(descriptor.nodes, otherDescriptor.nodes)\n      }\n      default:\n        return true\n    }\n  }\n\n  // Equal when all possible types are equal (including conflicts)\n  return isEqual(types, otherTypes) && types.every(childDescriptorsAreEqual)\n}\n\nconst nodeFields = (node, ignoredFields = new Set()) =>\n  Object.keys(node).filter(key => !ignoredFields.has(key))\n\nconst updateTypeMetadata = (metadata = initialMetadata(), operation, node) => {\n  if (metadata.disabled) {\n    return metadata\n  }\n  metadata.total = (metadata.total || 0) + (operation === `add` ? 1 : -1)\n  if (metadata.ignored) {\n    return metadata\n  }\n  const { ignoredFields, fieldMap = {} } = metadata\n\n  nodeFields(node, ignoredFields).forEach(field => {\n    let descriptor = fieldMap[field]\n    if (descriptor === undefined) {\n      descriptor = {}\n      fieldMap[field] = descriptor\n    }\n\n    updateValueDescriptor(\n      node.id,\n      field,\n      node[field],\n      operation,\n      descriptor,\n      metadata,\n      []\n    )\n  })\n  metadata.fieldMap = fieldMap\n  return metadata\n}\n\nconst ignore = (metadata = initialMetadata(), set = true) => {\n  metadata.ignored = set\n  metadata.fieldMap = {}\n  return metadata\n}\n\nconst disable = (metadata = initialMetadata(), set = true) => {\n  metadata.disabled = set\n  return metadata\n}\n\nconst addNode = (metadata, node) => updateTypeMetadata(metadata, `add`, node)\nconst deleteNode = (metadata, node) => updateTypeMetadata(metadata, `del`, node)\nconst addNodes = (metadata = initialMetadata(), nodes) =>\n  nodes.reduce(addNode, metadata)\n\nconst possibleTypes = (descriptor = {}) =>\n  Object.keys(descriptor).filter(type => descriptor[type].total > 0)\n\nconst isEmpty = ({ fieldMap }) =>\n  Object.keys(fieldMap).every(\n    field => possibleTypes(fieldMap[field]).length === 0\n  )\n\n// Even empty type may still have nodes\nconst hasNodes = typeMetadata => typeMetadata.total > 0\n\nconst haveEqualFields = (\n  { fieldMap = {} } = {},\n  { fieldMap: otherFieldMap = {} } = {}\n) => {\n  const fields = mergeObjectKeys(fieldMap, otherFieldMap)\n  return fields.every(field =>\n    descriptorsAreEqual(fieldMap[field], otherFieldMap[field])\n  )\n}\n\nconst initialMetadata = state => {\n  return {\n    typeName: undefined,\n    disabled: false,\n    ignored: false,\n    dirty: false,\n    total: 0,\n    ignoredFields: undefined,\n    fieldMap: {},\n    ...state,\n  }\n}\n\nmodule.exports = {\n  addNode,\n  addNodes,\n  deleteNode,\n  ignore,\n  disable,\n  isEmpty,\n  hasNodes,\n  haveEqualFields,\n  initialMetadata,\n}\n"],"file":"inference-metadata.js"}